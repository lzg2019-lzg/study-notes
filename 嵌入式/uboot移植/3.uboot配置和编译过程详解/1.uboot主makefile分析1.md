- [uboot主Makefile分析1](#uboot%e4%b8%bbmakefile%e5%88%86%e6%9e%901)
  - [1. uboot version确定](#1-uboot-version%e7%a1%ae%e5%ae%9a)
  - [2. HOSTARCH 和 HOSTOS](#2-hostarch-%e5%92%8c-hostos)
  - [3. 静默编译(50-54行)](#3-%e9%9d%99%e9%bb%98%e7%bc%96%e8%af%9150-54%e8%a1%8c)
  - [4. 2种编译方法](#4-2%e7%a7%8d%e7%bc%96%e8%af%91%e6%96%b9%e6%b3%95)


## uboot主Makefile分析1
### 1. uboot version确定
+ `uboot`的版本号分为3个级别：
  + `Makefile`的24-29行
  + `VERSION`: 主版本号
  + `PATCHLEVEL`: 次版本号
  + `SUBLEVEL`: 再次版本号
  + `EXTRAVERSION`: 另外附加的版本信息
  这4个用`.`分隔开共同构成了最终的版本号。
+ `Makefile`中版本号最终生成一个变量`U_BOOT_VERSION`，这个变量记录了`Makefile`中配置的版本号。
+ `include/version_autogenerated.h`文件是编译过程中自动生成的一个文件，所以源目录中没有，但是编译过后的`uboot`中就有了。这里面的内容是一个宏定义，宏定义的值内容就是我们在`Makefile`中配置的`uboot`的版本号。
  *`Makefile`中版本定义*
  ```powershell
  VERSION = 1
  PATCHLEVEL = 3
  SUBLEVEL = 4
  EXTRAVERSION = lzg
  U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
  VERSION_FILE = $(obj)include/version_autogenerated.h
  ```
  编译完成后，`include/`下会生成`version_autogenerated.h`文件
  ```powershell
  root@book-virtual-machine:/home/book/uboot/include# cat version_autogenerated.h 
  #define U_BOOT_VERSION "U-Boot 1.3.4lzg"

  ```
### 2. HOSTARCH 和 HOSTOS
+ 直接在`shell`中执行`uname -m `得到`i686`，得玛的值其实你当前执行这个命令的电脑的CPU的版本号。
+ `shell`中`|`叫做管道，管道的作用就是把管道前面一个运算式的输出作为后面一个的输入再去做处理，最终的输出才是我们整个式子的输出。
+ `HOSTARCH`: 主机的`CPU`的架构。
  ```powershell
  HOSTARCH := $(shell uname -m | \
    sed -e s/i.86/i386/ \
        -e s/sun4u/sparc64/ \
        -e s/arm.*/arm/ \
        -e s/sa110/arm/ \
        -e s/powerpc/ppc/ \
        -e s/ppc64/ppc/ \
        -e s/macppc/ppc/)
  ```
  执行结果为`x86_64`.
+ `HOSTOS`: 主机系统
  ```powershell
  HOSTOS := $(shell uname -s | tr '[:upper:]' '[:lower:]' | \
        sed -e 's/\(cygwin\).*/cygwin/')
  ```
  执行结果为`Linux`.

+ 这两个环境变量是主机的操作系统和主机的`CPU`架构，得出后保存备用。

### 3. 静默编译(50-54行)
+ 平时默认编译时命令行会打印出来很多编译信息。但是有时候我们不希望看到这些编译信息，后台编译即可，这就叫做静默编译。
+ 使用方法就是编译时用`make -s`, `-s`会作为`MAKEFLAGS`传给`Makefile`，在50-54行这段代码作用下`XECHO`变量就会被变成空（默认等于`echo`），于是实现了静默编译。
  ```powershell
  #########################################################################
  # Allow for silent builds
  ifeq (,$(findstring s,$(MAKEFLAGS)))
  XECHO = echo
  else
  XECHO = :
  endif
  ```
### 4. 2种编译方法
  **分原地编译和单独输出文件夹编译**
  + 编译复杂项目，`Makefile`提供2种编译管理方法。默认情况下是当前文件夹中的`.c`文件，编译出来的`.o`文件会放在同一个文件夹下。这种方式叫原地编译。原地编译的好处就是处理起来简单。
  + 原地编译有一些坏处：第一，污染了源文件目录。第二的缺陷就是一套源代码只能按照一种配置和编译方法进行处理，无法同时维护2个或22上以上的配置编译方式。
  + 为了解决以上两种缺陷，`uboot`支持单独输出文件夹方式的编译（`linux kernel`也支持，而且`uboot`的这种技术就是从`linux kernel`学习而来的）。基本思路就是在编译时另外指定一个编译目录，将来所有的编译生成的`.o`文件或生成的其他文件全部丢到那个输出目录下去。源代码目录不做任何污染，这样输出目录就承载了本次配置编译的所有结果。
  + 具体用法：默认的就是原地编译。如果需要指定具体的输出目录编译则有2种方式来指定输出目录。
  **`Makefile`中的注释说明**
    ```powershell
    #########################################################################
    #
    # U-boot build supports producing a object files to the separate external
    # directory. Two use cases are supported:
    #
    # 1) Add O= to the make command line
    # 'make O=/tmp/build all'
    #
    # 2) Set environement variable BUILD_DIR to point to the desired location
    # 'export BUILD_DIR=/tmp/build'
    # 'make'
    #
    # The second approach can also be used with a MAKEALL script
    # 'export BUILD_DIR=/tmp/build'
    # './MAKEALL'
    #
    # Command line 'O=' setting overrides BUILD_DIR environent variable.
    #
    # When none of the above methods is used the local build is performed and
    # the object files are placed in the source directory.
    #
    ```

    第一种：`make O=`输出目录
    第二种：`export BUILD_DIR=`输出目录，然后再`make`
    如果两个都指定了（即有`BUILD_DIR`环境变量存在，又有`O=XX`），则`O=XX`具有更高优先级。
+ 两种编译的实现代码在`Makefile`的78-123行。



